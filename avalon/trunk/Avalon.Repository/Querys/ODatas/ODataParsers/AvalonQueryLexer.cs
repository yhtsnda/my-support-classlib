//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 AvalonQuery.g3 2013-12-03 12:00:02

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Avalon.Framework.Querys
{
    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
    [System.CLSCompliant(false)]
    public partial class AvalonQueryLexer : Antlr.Runtime.Lexer
    {
        public const int EOF = -1;
        public const int ALLPAGES = 4;
        public const int AND = 5;
        public const int ASC = 6;
        public const int AVERAGE = 7;
        public const int BOOL = 8;
        public const int BYTE = 9;
        public const int COUNT = 10;
        public const int DATETIME = 11;
        public const int DESC = 12;
        public const int DOUBLE = 13;
        public const int ENDSWITH = 14;
        public const int EQUALS = 15;
        public const int ESC_SEQ = 16;
        public const int FILTER = 17;
        public const int GREATERTHAN = 18;
        public const int GREATERTHANOREQUAL = 19;
        public const int GUID = 20;
        public const int HEX_DIGIT = 21;
        public const int HEX_PAIR = 22;
        public const int IDENTIFIER = 23;
        public const int IN = 24;
        public const int INLINECOUNT = 25;
        public const int INT = 26;
        public const int LESSTHAN = 27;
        public const int LESSTHANOREQUAL = 28;
        public const int LONG = 29;
        public const int MAX = 30;
        public const int MIN = 31;
        public const int NEWLINE = 32;
        public const int NONE = 33;
        public const int NOT = 34;
        public const int NOTEQUALS = 35;
        public const int NOTIN = 36;
        public const int NULL = 37;
        public const int OCTAL_ESC = 38;
        public const int OR = 39;
        public const int ORDERBY = 40;
        public const int SELECT = 41;
        public const int SINGLE = 42;
        public const int SKIP = 43;
        public const int SPACE = 44;
        public const int STARTSWITH = 45;
        public const int STRING = 46;
        public const int SUBSTRINGOF = 47;
        public const int SUM = 48;
        public const int TOP = 49;
        public const int UNICODE_ESC = 50;
        public const int T__51 = 51;
        public const int T__52 = 52;
        public const int T__53 = 53;
        public const int T__54 = 54;

        // delegates
        // delegators

        public AvalonQueryLexer()
        {
            OnCreated();
        }

        public AvalonQueryLexer(ICharStream input)
            : this(input, new RecognizerSharedState())
        {
        }

        public AvalonQueryLexer(ICharStream input, RecognizerSharedState state)
            : base(input, state)
        {

            OnCreated();
        }
        public override string GrammarFileName { get { return "AvalonQuery.g3"; } }


        partial void OnCreated();
        partial void EnterRule(string ruleName, int ruleIndex);
        partial void LeaveRule(string ruleName, int ruleIndex);

        partial void EnterRule_T__51();
        partial void LeaveRule_T__51();

        // $ANTLR start "T__51"
        [GrammarRule("T__51")]
        private void mT__51()
        {
            EnterRule_T__51();
            EnterRule("T__51", 1);
            TraceIn("T__51", 1);
            try
            {
                int _type = T__51;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:10:7: ( '&' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:10:9: '&'
                {
                    DebugLocation(10, 9);
                    Match('&');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("T__51", 1);
                LeaveRule("T__51", 1);
                LeaveRule_T__51();
            }
        }
        // $ANTLR end "T__51"

        partial void EnterRule_T__52();
        partial void LeaveRule_T__52();

        // $ANTLR start "T__52"
        [GrammarRule("T__52")]
        private void mT__52()
        {
            EnterRule_T__52();
            EnterRule("T__52", 2);
            TraceIn("T__52", 2);
            try
            {
                int _type = T__52;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:11:7: ( '(' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:11:9: '('
                {
                    DebugLocation(11, 9);
                    Match('(');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("T__52", 2);
                LeaveRule("T__52", 2);
                LeaveRule_T__52();
            }
        }
        // $ANTLR end "T__52"

        partial void EnterRule_T__53();
        partial void LeaveRule_T__53();

        // $ANTLR start "T__53"
        [GrammarRule("T__53")]
        private void mT__53()
        {
            EnterRule_T__53();
            EnterRule("T__53", 3);
            TraceIn("T__53", 3);
            try
            {
                int _type = T__53;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:12:7: ( ')' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:12:9: ')'
                {
                    DebugLocation(12, 9);
                    Match(')');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("T__53", 3);
                LeaveRule("T__53", 3);
                LeaveRule_T__53();
            }
        }
        // $ANTLR end "T__53"

        partial void EnterRule_T__54();
        partial void LeaveRule_T__54();

        // $ANTLR start "T__54"
        [GrammarRule("T__54")]
        private void mT__54()
        {
            EnterRule_T__54();
            EnterRule("T__54", 4);
            TraceIn("T__54", 4);
            try
            {
                int _type = T__54;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:13:7: ( ',' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:13:9: ','
                {
                    DebugLocation(13, 9);
                    Match(',');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("T__54", 4);
                LeaveRule("T__54", 4);
                LeaveRule_T__54();
            }
        }
        // $ANTLR end "T__54"

        partial void EnterRule_IN();
        partial void LeaveRule_IN();

        // $ANTLR start "IN"
        [GrammarRule("IN")]
        private void mIN()
        {
            EnterRule_IN();
            EnterRule("IN", 5);
            TraceIn("IN", 5);
            try
            {
                int _type = IN;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:94:4: ( 'in' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:94:6: 'in'
                {
                    DebugLocation(94, 6);
                    Match("in");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("IN", 5);
                LeaveRule("IN", 5);
                LeaveRule_IN();
            }
        }
        // $ANTLR end "IN"

        partial void EnterRule_NOTIN();
        partial void LeaveRule_NOTIN();

        // $ANTLR start "NOTIN"
        [GrammarRule("NOTIN")]
        private void mNOTIN()
        {
            EnterRule_NOTIN();
            EnterRule("NOTIN", 6);
            TraceIn("NOTIN", 6);
            try
            {
                int _type = NOTIN;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:96:7: ( 'notin' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:96:9: 'notin'
                {
                    DebugLocation(96, 9);
                    Match("notin");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NOTIN", 6);
                LeaveRule("NOTIN", 6);
                LeaveRule_NOTIN();
            }
        }
        // $ANTLR end "NOTIN"

        partial void EnterRule_EQUALS();
        partial void LeaveRule_EQUALS();

        // $ANTLR start "EQUALS"
        [GrammarRule("EQUALS")]
        private void mEQUALS()
        {
            EnterRule_EQUALS();
            EnterRule("EQUALS", 7);
            TraceIn("EQUALS", 7);
            try
            {
                int _type = EQUALS;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:99:2: ( 'eq' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:99:4: 'eq'
                {
                    DebugLocation(99, 4);
                    Match("eq");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("EQUALS", 7);
                LeaveRule("EQUALS", 7);
                LeaveRule_EQUALS();
            }
        }
        // $ANTLR end "EQUALS"

        partial void EnterRule_NOTEQUALS();
        partial void LeaveRule_NOTEQUALS();

        // $ANTLR start "NOTEQUALS"
        [GrammarRule("NOTEQUALS")]
        private void mNOTEQUALS()
        {
            EnterRule_NOTEQUALS();
            EnterRule("NOTEQUALS", 8);
            TraceIn("NOTEQUALS", 8);
            try
            {
                int _type = NOTEQUALS;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:102:2: ( 'ne' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:102:4: 'ne'
                {
                    DebugLocation(102, 4);
                    Match("ne");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NOTEQUALS", 8);
                LeaveRule("NOTEQUALS", 8);
                LeaveRule_NOTEQUALS();
            }
        }
        // $ANTLR end "NOTEQUALS"

        partial void EnterRule_GREATERTHAN();
        partial void LeaveRule_GREATERTHAN();

        // $ANTLR start "GREATERTHAN"
        [GrammarRule("GREATERTHAN")]
        private void mGREATERTHAN()
        {
            EnterRule_GREATERTHAN();
            EnterRule("GREATERTHAN", 9);
            TraceIn("GREATERTHAN", 9);
            try
            {
                int _type = GREATERTHAN;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:105:2: ( 'gt' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:105:4: 'gt'
                {
                    DebugLocation(105, 4);
                    Match("gt");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("GREATERTHAN", 9);
                LeaveRule("GREATERTHAN", 9);
                LeaveRule_GREATERTHAN();
            }
        }
        // $ANTLR end "GREATERTHAN"

        partial void EnterRule_GREATERTHANOREQUAL();
        partial void LeaveRule_GREATERTHANOREQUAL();

        // $ANTLR start "GREATERTHANOREQUAL"
        [GrammarRule("GREATERTHANOREQUAL")]
        private void mGREATERTHANOREQUAL()
        {
            EnterRule_GREATERTHANOREQUAL();
            EnterRule("GREATERTHANOREQUAL", 10);
            TraceIn("GREATERTHANOREQUAL", 10);
            try
            {
                int _type = GREATERTHANOREQUAL;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:108:2: ( 'ge' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:108:4: 'ge'
                {
                    DebugLocation(108, 4);
                    Match("ge");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("GREATERTHANOREQUAL", 10);
                LeaveRule("GREATERTHANOREQUAL", 10);
                LeaveRule_GREATERTHANOREQUAL();
            }
        }
        // $ANTLR end "GREATERTHANOREQUAL"

        partial void EnterRule_LESSTHAN();
        partial void LeaveRule_LESSTHAN();

        // $ANTLR start "LESSTHAN"
        [GrammarRule("LESSTHAN")]
        private void mLESSTHAN()
        {
            EnterRule_LESSTHAN();
            EnterRule("LESSTHAN", 11);
            TraceIn("LESSTHAN", 11);
            try
            {
                int _type = LESSTHAN;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:111:2: ( 'lt' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:111:4: 'lt'
                {
                    DebugLocation(111, 4);
                    Match("lt");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LESSTHAN", 11);
                LeaveRule("LESSTHAN", 11);
                LeaveRule_LESSTHAN();
            }
        }
        // $ANTLR end "LESSTHAN"

        partial void EnterRule_LESSTHANOREQUAL();
        partial void LeaveRule_LESSTHANOREQUAL();

        // $ANTLR start "LESSTHANOREQUAL"
        [GrammarRule("LESSTHANOREQUAL")]
        private void mLESSTHANOREQUAL()
        {
            EnterRule_LESSTHANOREQUAL();
            EnterRule("LESSTHANOREQUAL", 12);
            TraceIn("LESSTHANOREQUAL", 12);
            try
            {
                int _type = LESSTHANOREQUAL;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:114:2: ( 'le' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:114:4: 'le'
                {
                    DebugLocation(114, 4);
                    Match("le");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LESSTHANOREQUAL", 12);
                LeaveRule("LESSTHANOREQUAL", 12);
                LeaveRule_LESSTHANOREQUAL();
            }
        }
        // $ANTLR end "LESSTHANOREQUAL"

        partial void EnterRule_NOT();
        partial void LeaveRule_NOT();

        // $ANTLR start "NOT"
        [GrammarRule("NOT")]
        private void mNOT()
        {
            EnterRule_NOT();
            EnterRule("NOT", 13);
            TraceIn("NOT", 13);
            try
            {
                int _type = NOT;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:117:2: ( 'not' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:117:4: 'not'
                {
                    DebugLocation(117, 4);
                    Match("not");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NOT", 13);
                LeaveRule("NOT", 13);
                LeaveRule_NOT();
            }
        }
        // $ANTLR end "NOT"

        partial void EnterRule_OR();
        partial void LeaveRule_OR();

        // $ANTLR start "OR"
        [GrammarRule("OR")]
        private void mOR()
        {
            EnterRule_OR();
            EnterRule("OR", 14);
            TraceIn("OR", 14);
            try
            {
                int _type = OR;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:120:2: ( 'or' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:120:4: 'or'
                {
                    DebugLocation(120, 4);
                    Match("or");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("OR", 14);
                LeaveRule("OR", 14);
                LeaveRule_OR();
            }
        }
        // $ANTLR end "OR"

        partial void EnterRule_AND();
        partial void LeaveRule_AND();

        // $ANTLR start "AND"
        [GrammarRule("AND")]
        private void mAND()
        {
            EnterRule_AND();
            EnterRule("AND", 15);
            TraceIn("AND", 15);
            try
            {
                int _type = AND;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:123:2: ( 'and' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:123:5: 'and'
                {
                    DebugLocation(123, 5);
                    Match("and");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("AND", 15);
                LeaveRule("AND", 15);
                LeaveRule_AND();
            }
        }
        // $ANTLR end "AND"

        partial void EnterRule_ASC();
        partial void LeaveRule_ASC();

        // $ANTLR start "ASC"
        [GrammarRule("ASC")]
        private void mASC()
        {
            EnterRule_ASC();
            EnterRule("ASC", 16);
            TraceIn("ASC", 16);
            try
            {
                int _type = ASC;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:126:2: ( 'asc' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:126:4: 'asc'
                {
                    DebugLocation(126, 4);
                    Match("asc");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ASC", 16);
                LeaveRule("ASC", 16);
                LeaveRule_ASC();
            }
        }
        // $ANTLR end "ASC"

        partial void EnterRule_DESC();
        partial void LeaveRule_DESC();

        // $ANTLR start "DESC"
        [GrammarRule("DESC")]
        private void mDESC()
        {
            EnterRule_DESC();
            EnterRule("DESC", 17);
            TraceIn("DESC", 17);
            try
            {
                int _type = DESC;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:129:2: ( 'desc' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:129:4: 'desc'
                {
                    DebugLocation(129, 4);
                    Match("desc");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("DESC", 17);
                LeaveRule("DESC", 17);
                LeaveRule_DESC();
            }
        }
        // $ANTLR end "DESC"

        partial void EnterRule_ALLPAGES();
        partial void LeaveRule_ALLPAGES();

        // $ANTLR start "ALLPAGES"
        [GrammarRule("ALLPAGES")]
        private void mALLPAGES()
        {
            EnterRule_ALLPAGES();
            EnterRule("ALLPAGES", 18);
            TraceIn("ALLPAGES", 18);
            try
            {
                int _type = ALLPAGES;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:132:2: ( 'allpages' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:132:5: 'allpages'
                {
                    DebugLocation(132, 5);
                    Match("allpages");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ALLPAGES", 18);
                LeaveRule("ALLPAGES", 18);
                LeaveRule_ALLPAGES();
            }
        }
        // $ANTLR end "ALLPAGES"

        partial void EnterRule_NONE();
        partial void LeaveRule_NONE();

        // $ANTLR start "NONE"
        [GrammarRule("NONE")]
        private void mNONE()
        {
            EnterRule_NONE();
            EnterRule("NONE", 19);
            TraceIn("NONE", 19);
            try
            {
                int _type = NONE;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:135:2: ( 'none' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:135:4: 'none'
                {
                    DebugLocation(135, 4);
                    Match("none");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NONE", 19);
                LeaveRule("NONE", 19);
                LeaveRule_NONE();
            }
        }
        // $ANTLR end "NONE"

        partial void EnterRule_SKIP();
        partial void LeaveRule_SKIP();

        // $ANTLR start "SKIP"
        [GrammarRule("SKIP")]
        private void mSKIP()
        {
            EnterRule_SKIP();
            EnterRule("SKIP", 20);
            TraceIn("SKIP", 20);
            try
            {
                int _type = SKIP;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:138:2: ( '$skip=' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:138:4: '$skip='
                {
                    DebugLocation(138, 4);
                    Match("$skip=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SKIP", 20);
                LeaveRule("SKIP", 20);
                LeaveRule_SKIP();
            }
        }
        // $ANTLR end "SKIP"

        partial void EnterRule_TOP();
        partial void LeaveRule_TOP();

        // $ANTLR start "TOP"
        [GrammarRule("TOP")]
        private void mTOP()
        {
            EnterRule_TOP();
            EnterRule("TOP", 21);
            TraceIn("TOP", 21);
            try
            {
                int _type = TOP;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:141:2: ( '$top=' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:141:4: '$top='
                {
                    DebugLocation(141, 4);
                    Match("$top=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("TOP", 21);
                LeaveRule("TOP", 21);
                LeaveRule_TOP();
            }
        }
        // $ANTLR end "TOP"

        partial void EnterRule_FILTER();
        partial void LeaveRule_FILTER();

        // $ANTLR start "FILTER"
        [GrammarRule("FILTER")]
        private void mFILTER()
        {
            EnterRule_FILTER();
            EnterRule("FILTER", 22);
            TraceIn("FILTER", 22);
            try
            {
                int _type = FILTER;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:144:2: ( '$filter=' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:144:4: '$filter='
                {
                    DebugLocation(144, 4);
                    Match("$filter=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("FILTER", 22);
                LeaveRule("FILTER", 22);
                LeaveRule_FILTER();
            }
        }
        // $ANTLR end "FILTER"

        partial void EnterRule_ORDERBY();
        partial void LeaveRule_ORDERBY();

        // $ANTLR start "ORDERBY"
        [GrammarRule("ORDERBY")]
        private void mORDERBY()
        {
            EnterRule_ORDERBY();
            EnterRule("ORDERBY", 23);
            TraceIn("ORDERBY", 23);
            try
            {
                int _type = ORDERBY;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:148:2: ( '$orderby=' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:148:4: '$orderby='
                {
                    DebugLocation(148, 4);
                    Match("$orderby=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ORDERBY", 23);
                LeaveRule("ORDERBY", 23);
                LeaveRule_ORDERBY();
            }
        }
        // $ANTLR end "ORDERBY"

        partial void EnterRule_SELECT();
        partial void LeaveRule_SELECT();

        // $ANTLR start "SELECT"
        [GrammarRule("SELECT")]
        private void mSELECT()
        {
            EnterRule_SELECT();
            EnterRule("SELECT", 24);
            TraceIn("SELECT", 24);
            try
            {
                int _type = SELECT;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:151:2: ( '$select=' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:151:4: '$select='
                {
                    DebugLocation(151, 4);
                    Match("$select=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SELECT", 24);
                LeaveRule("SELECT", 24);
                LeaveRule_SELECT();
            }
        }
        // $ANTLR end "SELECT"

        partial void EnterRule_INLINECOUNT();
        partial void LeaveRule_INLINECOUNT();

        // $ANTLR start "INLINECOUNT"
        [GrammarRule("INLINECOUNT")]
        private void mINLINECOUNT()
        {
            EnterRule_INLINECOUNT();
            EnterRule("INLINECOUNT", 25);
            TraceIn("INLINECOUNT", 25);
            try
            {
                int _type = INLINECOUNT;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:154:2: ( '$inlinecount=' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:154:4: '$inlinecount='
                {
                    DebugLocation(154, 4);
                    Match("$inlinecount=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("INLINECOUNT", 25);
                LeaveRule("INLINECOUNT", 25);
                LeaveRule_INLINECOUNT();
            }
        }
        // $ANTLR end "INLINECOUNT"

        partial void EnterRule_COUNT();
        partial void LeaveRule_COUNT();

        // $ANTLR start "COUNT"
        [GrammarRule("COUNT")]
        private void mCOUNT()
        {
            EnterRule_COUNT();
            EnterRule("COUNT", 26);
            TraceIn("COUNT", 26);
            try
            {
                int _type = COUNT;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:157:2: ( '$count=' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:157:4: '$count='
                {
                    DebugLocation(157, 4);
                    Match("$count=");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("COUNT", 26);
                LeaveRule("COUNT", 26);
                LeaveRule_COUNT();
            }
        }
        // $ANTLR end "COUNT"

        partial void EnterRule_STARTSWITH();
        partial void LeaveRule_STARTSWITH();

        // $ANTLR start "STARTSWITH"
        [GrammarRule("STARTSWITH")]
        private void mSTARTSWITH()
        {
            EnterRule_STARTSWITH();
            EnterRule("STARTSWITH", 27);
            TraceIn("STARTSWITH", 27);
            try
            {
                int _type = STARTSWITH;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:160:2: ( 'startswith' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:160:4: 'startswith'
                {
                    DebugLocation(160, 4);
                    Match("startswith");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("STARTSWITH", 27);
                LeaveRule("STARTSWITH", 27);
                LeaveRule_STARTSWITH();
            }
        }
        // $ANTLR end "STARTSWITH"

        partial void EnterRule_ENDSWITH();
        partial void LeaveRule_ENDSWITH();

        // $ANTLR start "ENDSWITH"
        [GrammarRule("ENDSWITH")]
        private void mENDSWITH()
        {
            EnterRule_ENDSWITH();
            EnterRule("ENDSWITH", 28);
            TraceIn("ENDSWITH", 28);
            try
            {
                int _type = ENDSWITH;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:163:2: ( 'endswith' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:163:4: 'endswith'
                {
                    DebugLocation(163, 4);
                    Match("endswith");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("ENDSWITH", 28);
                LeaveRule("ENDSWITH", 28);
                LeaveRule_ENDSWITH();
            }
        }
        // $ANTLR end "ENDSWITH"

        partial void EnterRule_SUBSTRINGOF();
        partial void LeaveRule_SUBSTRINGOF();

        // $ANTLR start "SUBSTRINGOF"
        [GrammarRule("SUBSTRINGOF")]
        private void mSUBSTRINGOF()
        {
            EnterRule_SUBSTRINGOF();
            EnterRule("SUBSTRINGOF", 29);
            TraceIn("SUBSTRINGOF", 29);
            try
            {
                int _type = SUBSTRINGOF;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:166:2: ( 'substringof' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:166:4: 'substringof'
                {
                    DebugLocation(166, 4);
                    Match("substringof");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SUBSTRINGOF", 29);
                LeaveRule("SUBSTRINGOF", 29);
                LeaveRule_SUBSTRINGOF();
            }
        }
        // $ANTLR end "SUBSTRINGOF"

        partial void EnterRule_MIN();
        partial void LeaveRule_MIN();

        // $ANTLR start "MIN"
        [GrammarRule("MIN")]
        private void mMIN()
        {
            EnterRule_MIN();
            EnterRule("MIN", 30);
            TraceIn("MIN", 30);
            try
            {
                int _type = MIN;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:168:5: ( 'min' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:168:7: 'min'
                {
                    DebugLocation(168, 7);
                    Match("min");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("MIN", 30);
                LeaveRule("MIN", 30);
                LeaveRule_MIN();
            }
        }
        // $ANTLR end "MIN"

        partial void EnterRule_MAX();
        partial void LeaveRule_MAX();

        // $ANTLR start "MAX"
        [GrammarRule("MAX")]
        private void mMAX()
        {
            EnterRule_MAX();
            EnterRule("MAX", 31);
            TraceIn("MAX", 31);
            try
            {
                int _type = MAX;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:170:5: ( 'max' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:170:7: 'max'
                {
                    DebugLocation(170, 7);
                    Match("max");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("MAX", 31);
                LeaveRule("MAX", 31);
                LeaveRule_MAX();
            }
        }
        // $ANTLR end "MAX"

        partial void EnterRule_SUM();
        partial void LeaveRule_SUM();

        // $ANTLR start "SUM"
        [GrammarRule("SUM")]
        private void mSUM()
        {
            EnterRule_SUM();
            EnterRule("SUM", 32);
            TraceIn("SUM", 32);
            try
            {
                int _type = SUM;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:172:5: ( 'sum' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:172:7: 'sum'
                {
                    DebugLocation(172, 7);
                    Match("sum");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SUM", 32);
                LeaveRule("SUM", 32);
                LeaveRule_SUM();
            }
        }
        // $ANTLR end "SUM"

        partial void EnterRule_AVERAGE();
        partial void LeaveRule_AVERAGE();

        // $ANTLR start "AVERAGE"
        [GrammarRule("AVERAGE")]
        private void mAVERAGE()
        {
            EnterRule_AVERAGE();
            EnterRule("AVERAGE", 33);
            TraceIn("AVERAGE", 33);
            try
            {
                int _type = AVERAGE;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:174:9: ( 'average' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:174:11: 'average'
                {
                    DebugLocation(174, 11);
                    Match("average");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("AVERAGE", 33);
                LeaveRule("AVERAGE", 33);
                LeaveRule_AVERAGE();
            }
        }
        // $ANTLR end "AVERAGE"

        partial void EnterRule_INT();
        partial void LeaveRule_INT();

        // $ANTLR start "INT"
        [GrammarRule("INT")]
        private void mINT()
        {
            EnterRule_INT();
            EnterRule("INT", 34);
            TraceIn("INT", 34);
            try
            {
                int _type = INT;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:176:5: ( ( '-' )? ( '0' .. '9' )+ )
                DebugEnterAlt(1);
                // AvalonQuery.g3:176:7: ( '-' )? ( '0' .. '9' )+
                {
                    DebugLocation(176, 7);
                    // AvalonQuery.g3:176:7: ( '-' )?
                    int alt1 = 2;
                    try
                    {
                        DebugEnterSubRule(1);
                        try
                        {
                            DebugEnterDecision(1, false);
                            int LA1_1 = input.LA(1);

                            if ((LA1_1 == '-'))
                            {
                                alt1 = 1;
                            }
                        }
                        finally { DebugExitDecision(1); }
                        switch (alt1)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // AvalonQuery.g3:176:8: '-'
                                {
                                    DebugLocation(176, 8);
                                    Match('-');

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(1); }

                    DebugLocation(176, 17);
                    // AvalonQuery.g3:176:17: ( '0' .. '9' )+
                    int cnt2 = 0;
                    try
                    {
                        DebugEnterSubRule(2);
                        while (true)
                        {
                            int alt2 = 2;
                            try
                            {
                                DebugEnterDecision(2, false);
                                int LA2_1 = input.LA(1);

                                if (((LA2_1 >= '0' && LA2_1 <= '9')))
                                {
                                    alt2 = 1;
                                }


                            }
                            finally { DebugExitDecision(2); }
                            switch (alt2)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(176, 17);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt2 >= 1)
                                        goto loop2;

                                    EarlyExitException eee2 = new EarlyExitException(2, input);
                                    DebugRecognitionException(eee2);
                                    throw eee2;
                            }
                            cnt2++;
                        }
                    loop2:
                        ;

                    }
                    finally { DebugExitSubRule(2); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("INT", 34);
                LeaveRule("INT", 34);
                LeaveRule_INT();
            }
        }
        // $ANTLR end "INT"

        partial void EnterRule_LONG();
        partial void LeaveRule_LONG();

        // $ANTLR start "LONG"
        [GrammarRule("LONG")]
        private void mLONG()
        {
            EnterRule_LONG();
            EnterRule("LONG", 35);
            TraceIn("LONG", 35);
            try
            {
                int _type = LONG;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:178:6: ( ( '-' )? ( '0' .. '9' )+ 'L' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:178:8: ( '-' )? ( '0' .. '9' )+ 'L'
                {
                    DebugLocation(178, 8);
                    // AvalonQuery.g3:178:8: ( '-' )?
                    int alt3 = 2;
                    try
                    {
                        DebugEnterSubRule(3);
                        try
                        {
                            DebugEnterDecision(3, false);
                            int LA3_1 = input.LA(1);

                            if ((LA3_1 == '-'))
                            {
                                alt3 = 1;
                            }
                        }
                        finally { DebugExitDecision(3); }
                        switch (alt3)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // AvalonQuery.g3:178:9: '-'
                                {
                                    DebugLocation(178, 9);
                                    Match('-');

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(3); }

                    DebugLocation(178, 15);
                    // AvalonQuery.g3:178:15: ( '0' .. '9' )+
                    int cnt4 = 0;
                    try
                    {
                        DebugEnterSubRule(4);
                        while (true)
                        {
                            int alt4 = 2;
                            try
                            {
                                DebugEnterDecision(4, false);
                                int LA4_1 = input.LA(1);

                                if (((LA4_1 >= '0' && LA4_1 <= '9')))
                                {
                                    alt4 = 1;
                                }


                            }
                            finally { DebugExitDecision(4); }
                            switch (alt4)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(178, 15);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt4 >= 1)
                                        goto loop4;

                                    EarlyExitException eee4 = new EarlyExitException(4, input);
                                    DebugRecognitionException(eee4);
                                    throw eee4;
                            }
                            cnt4++;
                        }
                    loop4:
                        ;

                    }
                    finally { DebugExitSubRule(4); }

                    DebugLocation(178, 27);
                    Match('L');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("LONG", 35);
                LeaveRule("LONG", 35);
                LeaveRule_LONG();
            }
        }
        // $ANTLR end "LONG"

        partial void EnterRule_DOUBLE();
        partial void LeaveRule_DOUBLE();

        // $ANTLR start "DOUBLE"
        [GrammarRule("DOUBLE")]
        private void mDOUBLE()
        {
            EnterRule_DOUBLE();
            EnterRule("DOUBLE", 36);
            TraceIn("DOUBLE", 36);
            try
            {
                int _type = DOUBLE;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:180:8: ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )+ )
                DebugEnterAlt(1);
                // AvalonQuery.g3:180:10: ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )+
                {
                    DebugLocation(180, 10);
                    // AvalonQuery.g3:180:10: ( '-' )?
                    int alt5 = 2;
                    try
                    {
                        DebugEnterSubRule(5);
                        try
                        {
                            DebugEnterDecision(5, false);
                            int LA5_1 = input.LA(1);

                            if ((LA5_1 == '-'))
                            {
                                alt5 = 1;
                            }
                        }
                        finally { DebugExitDecision(5); }
                        switch (alt5)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // AvalonQuery.g3:180:11: '-'
                                {
                                    DebugLocation(180, 11);
                                    Match('-');

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(5); }

                    DebugLocation(180, 17);
                    // AvalonQuery.g3:180:17: ( '0' .. '9' )+
                    int cnt6 = 0;
                    try
                    {
                        DebugEnterSubRule(6);
                        while (true)
                        {
                            int alt6 = 2;
                            try
                            {
                                DebugEnterDecision(6, false);
                                int LA6_1 = input.LA(1);

                                if (((LA6_1 >= '0' && LA6_1 <= '9')))
                                {
                                    alt6 = 1;
                                }


                            }
                            finally { DebugExitDecision(6); }
                            switch (alt6)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(180, 17);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt6 >= 1)
                                        goto loop6;

                                    EarlyExitException eee6 = new EarlyExitException(6, input);
                                    DebugRecognitionException(eee6);
                                    throw eee6;
                            }
                            cnt6++;
                        }
                    loop6:
                        ;

                    }
                    finally { DebugExitSubRule(6); }

                    DebugLocation(180, 29);
                    Match('.');
                    DebugLocation(180, 33);
                    // AvalonQuery.g3:180:33: ( '0' .. '9' )+
                    int cnt7 = 0;
                    try
                    {
                        DebugEnterSubRule(7);
                        while (true)
                        {
                            int alt7 = 2;
                            try
                            {
                                DebugEnterDecision(7, false);
                                int LA7_1 = input.LA(1);

                                if (((LA7_1 >= '0' && LA7_1 <= '9')))
                                {
                                    alt7 = 1;
                                }


                            }
                            finally { DebugExitDecision(7); }
                            switch (alt7)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(180, 33);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt7 >= 1)
                                        goto loop7;

                                    EarlyExitException eee7 = new EarlyExitException(7, input);
                                    DebugRecognitionException(eee7);
                                    throw eee7;
                            }
                            cnt7++;
                        }
                    loop7:
                        ;

                    }
                    finally { DebugExitSubRule(7); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("DOUBLE", 36);
                LeaveRule("DOUBLE", 36);
                LeaveRule_DOUBLE();
            }
        }
        // $ANTLR end "DOUBLE"

        partial void EnterRule_SINGLE();
        partial void LeaveRule_SINGLE();

        // $ANTLR start "SINGLE"
        [GrammarRule("SINGLE")]
        private void mSINGLE()
        {
            EnterRule_SINGLE();
            EnterRule("SINGLE", 37);
            TraceIn("SINGLE", 37);
            try
            {
                int _type = SINGLE;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:182:8: ( ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )+ 'f' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:182:10: ( '-' )? ( '0' .. '9' )+ '.' ( '0' .. '9' )+ 'f'
                {
                    DebugLocation(182, 10);
                    // AvalonQuery.g3:182:10: ( '-' )?
                    int alt8 = 2;
                    try
                    {
                        DebugEnterSubRule(8);
                        try
                        {
                            DebugEnterDecision(8, false);
                            int LA8_1 = input.LA(1);

                            if ((LA8_1 == '-'))
                            {
                                alt8 = 1;
                            }
                        }
                        finally { DebugExitDecision(8); }
                        switch (alt8)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // AvalonQuery.g3:182:11: '-'
                                {
                                    DebugLocation(182, 11);
                                    Match('-');

                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(8); }

                    DebugLocation(182, 17);
                    // AvalonQuery.g3:182:17: ( '0' .. '9' )+
                    int cnt9 = 0;
                    try
                    {
                        DebugEnterSubRule(9);
                        while (true)
                        {
                            int alt9 = 2;
                            try
                            {
                                DebugEnterDecision(9, false);
                                int LA9_1 = input.LA(1);

                                if (((LA9_1 >= '0' && LA9_1 <= '9')))
                                {
                                    alt9 = 1;
                                }


                            }
                            finally { DebugExitDecision(9); }
                            switch (alt9)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(182, 17);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt9 >= 1)
                                        goto loop9;

                                    EarlyExitException eee9 = new EarlyExitException(9, input);
                                    DebugRecognitionException(eee9);
                                    throw eee9;
                            }
                            cnt9++;
                        }
                    loop9:
                        ;

                    }
                    finally { DebugExitSubRule(9); }

                    DebugLocation(182, 29);
                    Match('.');
                    DebugLocation(182, 33);
                    // AvalonQuery.g3:182:33: ( '0' .. '9' )+
                    int cnt10 = 0;
                    try
                    {
                        DebugEnterSubRule(10);
                        while (true)
                        {
                            int alt10 = 2;
                            try
                            {
                                DebugEnterDecision(10, false);
                                int LA10_1 = input.LA(1);

                                if (((LA10_1 >= '0' && LA10_1 <= '9')))
                                {
                                    alt10 = 1;
                                }


                            }
                            finally { DebugExitDecision(10); }
                            switch (alt10)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(182, 33);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt10 >= 1)
                                        goto loop10;

                                    EarlyExitException eee10 = new EarlyExitException(10, input);
                                    DebugRecognitionException(eee10);
                                    throw eee10;
                            }
                            cnt10++;
                        }
                    loop10:
                        ;

                    }
                    finally { DebugExitSubRule(10); }

                    DebugLocation(182, 45);
                    Match('f');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SINGLE", 37);
                LeaveRule("SINGLE", 37);
                LeaveRule_SINGLE();
            }
        }
        // $ANTLR end "SINGLE"

        partial void EnterRule_BOOL();
        partial void LeaveRule_BOOL();

        // $ANTLR start "BOOL"
        [GrammarRule("BOOL")]
        private void mBOOL()
        {
            EnterRule_BOOL();
            EnterRule("BOOL", 38);
            TraceIn("BOOL", 38);
            try
            {
                int _type = BOOL;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:184:6: ( ( 'true' | 'false' ) )
                DebugEnterAlt(1);
                // AvalonQuery.g3:184:8: ( 'true' | 'false' )
                {
                    DebugLocation(184, 8);
                    // AvalonQuery.g3:184:8: ( 'true' | 'false' )
                    int alt11 = 2;
                    try
                    {
                        DebugEnterSubRule(11);
                        try
                        {
                            DebugEnterDecision(11, false);
                            int LA11_1 = input.LA(1);

                            if ((LA11_1 == 't'))
                            {
                                alt11 = 1;
                            }
                            else if ((LA11_1 == 'f'))
                            {
                                alt11 = 2;
                            }
                            else
                            {
                                NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
                                DebugRecognitionException(nvae);
                                throw nvae;
                            }
                        }
                        finally { DebugExitDecision(11); }
                        switch (alt11)
                        {
                            case 1:
                                DebugEnterAlt(1);
                                // AvalonQuery.g3:184:9: 'true'
                                {
                                    DebugLocation(184, 9);
                                    Match("true");


                                }
                                break;
                            case 2:
                                DebugEnterAlt(2);
                                // AvalonQuery.g3:184:18: 'false'
                                {
                                    DebugLocation(184, 18);
                                    Match("false");


                                }
                                break;

                        }
                    }
                    finally { DebugExitSubRule(11); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("BOOL", 38);
                LeaveRule("BOOL", 38);
                LeaveRule_BOOL();
            }
        }
        // $ANTLR end "BOOL"

        partial void EnterRule_NULL();
        partial void LeaveRule_NULL();

        // $ANTLR start "NULL"
        [GrammarRule("NULL")]
        private void mNULL()
        {
            EnterRule_NULL();
            EnterRule("NULL", 39);
            TraceIn("NULL", 39);
            try
            {
                int _type = NULL;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:186:6: ( 'null' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:186:8: 'null'
                {
                    DebugLocation(186, 8);
                    Match("null");


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NULL", 39);
                LeaveRule("NULL", 39);
                LeaveRule_NULL();
            }
        }
        // $ANTLR end "NULL"

        partial void EnterRule_DATETIME();
        partial void LeaveRule_DATETIME();

        // $ANTLR start "DATETIME"
        [GrammarRule("DATETIME")]
        private void mDATETIME()
        {
            EnterRule_DATETIME();
            EnterRule("DATETIME", 40);
            TraceIn("DATETIME", 40);
            try
            {
                int _type = DATETIME;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:189:2: ( 'datetime\\'' ( '0' .. '9' )+ '-' ( '0' .. '9' )+ ( '-' )+ ( '0' .. '9' )+ 'T' ( '0' .. '9' )+ ':' ( '0' .. '9' )+ ( ':' ( '0' .. '9' )+ ( '.' ( '0' .. '9' )+ )* )* '\\'' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:189:4: 'datetime\\'' ( '0' .. '9' )+ '-' ( '0' .. '9' )+ ( '-' )+ ( '0' .. '9' )+ 'T' ( '0' .. '9' )+ ':' ( '0' .. '9' )+ ( ':' ( '0' .. '9' )+ ( '.' ( '0' .. '9' )+ )* )* '\\''
                {
                    DebugLocation(189, 4);
                    Match("datetime'");

                    DebugLocation(189, 20);
                    // AvalonQuery.g3:189:20: ( '0' .. '9' )+
                    int cnt12 = 0;
                    try
                    {
                        DebugEnterSubRule(12);
                        while (true)
                        {
                            int alt12 = 2;
                            try
                            {
                                DebugEnterDecision(12, false);
                                int LA12_1 = input.LA(1);

                                if (((LA12_1 >= '0' && LA12_1 <= '9')))
                                {
                                    alt12 = 1;
                                }


                            }
                            finally { DebugExitDecision(12); }
                            switch (alt12)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(189, 20);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt12 >= 1)
                                        goto loop12;

                                    EarlyExitException eee12 = new EarlyExitException(12, input);
                                    DebugRecognitionException(eee12);
                                    throw eee12;
                            }
                            cnt12++;
                        }
                    loop12:
                        ;

                    }
                    finally { DebugExitSubRule(12); }

                    DebugLocation(189, 27);
                    Match('-');
                    DebugLocation(189, 34);
                    // AvalonQuery.g3:189:34: ( '0' .. '9' )+
                    int cnt13 = 0;
                    try
                    {
                        DebugEnterSubRule(13);
                        while (true)
                        {
                            int alt13 = 2;
                            try
                            {
                                DebugEnterDecision(13, false);
                                int LA13_1 = input.LA(1);

                                if (((LA13_1 >= '0' && LA13_1 <= '9')))
                                {
                                    alt13 = 1;
                                }


                            }
                            finally { DebugExitDecision(13); }
                            switch (alt13)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(189, 34);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt13 >= 1)
                                        goto loop13;

                                    EarlyExitException eee13 = new EarlyExitException(13, input);
                                    DebugRecognitionException(eee13);
                                    throw eee13;
                            }
                            cnt13++;
                        }
                    loop13:
                        ;

                    }
                    finally { DebugExitSubRule(13); }

                    DebugLocation(189, 41);
                    // AvalonQuery.g3:189:41: ( '-' )+
                    int cnt14 = 0;
                    try
                    {
                        DebugEnterSubRule(14);
                        while (true)
                        {
                            int alt14 = 2;
                            try
                            {
                                DebugEnterDecision(14, false);
                                int LA14_1 = input.LA(1);

                                if ((LA14_1 == '-'))
                                {
                                    alt14 = 1;
                                }


                            }
                            finally { DebugExitDecision(14); }
                            switch (alt14)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:189:41: '-'
                                    {
                                        DebugLocation(189, 41);
                                        Match('-');

                                    }
                                    break;

                                default:
                                    if (cnt14 >= 1)
                                        goto loop14;

                                    EarlyExitException eee14 = new EarlyExitException(14, input);
                                    DebugRecognitionException(eee14);
                                    throw eee14;
                            }
                            cnt14++;
                        }
                    loop14:
                        ;

                    }
                    finally { DebugExitSubRule(14); }

                    DebugLocation(189, 50);
                    // AvalonQuery.g3:189:50: ( '0' .. '9' )+
                    int cnt15 = 0;
                    try
                    {
                        DebugEnterSubRule(15);
                        while (true)
                        {
                            int alt15 = 2;
                            try
                            {
                                DebugEnterDecision(15, false);
                                int LA15_1 = input.LA(1);

                                if (((LA15_1 >= '0' && LA15_1 <= '9')))
                                {
                                    alt15 = 1;
                                }


                            }
                            finally { DebugExitDecision(15); }
                            switch (alt15)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(189, 50);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt15 >= 1)
                                        goto loop15;

                                    EarlyExitException eee15 = new EarlyExitException(15, input);
                                    DebugRecognitionException(eee15);
                                    throw eee15;
                            }
                            cnt15++;
                        }
                    loop15:
                        ;

                    }
                    finally { DebugExitSubRule(15); }

                    DebugLocation(189, 57);
                    Match('T');
                    DebugLocation(189, 64);
                    // AvalonQuery.g3:189:64: ( '0' .. '9' )+
                    int cnt16 = 0;
                    try
                    {
                        DebugEnterSubRule(16);
                        while (true)
                        {
                            int alt16 = 2;
                            try
                            {
                                DebugEnterDecision(16, false);
                                int LA16_1 = input.LA(1);

                                if (((LA16_1 >= '0' && LA16_1 <= '9')))
                                {
                                    alt16 = 1;
                                }


                            }
                            finally { DebugExitDecision(16); }
                            switch (alt16)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(189, 64);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt16 >= 1)
                                        goto loop16;

                                    EarlyExitException eee16 = new EarlyExitException(16, input);
                                    DebugRecognitionException(eee16);
                                    throw eee16;
                            }
                            cnt16++;
                        }
                    loop16:
                        ;

                    }
                    finally { DebugExitSubRule(16); }

                    DebugLocation(189, 71);
                    Match(':');
                    DebugLocation(189, 78);
                    // AvalonQuery.g3:189:78: ( '0' .. '9' )+
                    int cnt17 = 0;
                    try
                    {
                        DebugEnterSubRule(17);
                        while (true)
                        {
                            int alt17 = 2;
                            try
                            {
                                DebugEnterDecision(17, false);
                                int LA17_1 = input.LA(1);

                                if (((LA17_1 >= '0' && LA17_1 <= '9')))
                                {
                                    alt17 = 1;
                                }


                            }
                            finally { DebugExitDecision(17); }
                            switch (alt17)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(189, 78);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt17 >= 1)
                                        goto loop17;

                                    EarlyExitException eee17 = new EarlyExitException(17, input);
                                    DebugRecognitionException(eee17);
                                    throw eee17;
                            }
                            cnt17++;
                        }
                    loop17:
                        ;

                    }
                    finally { DebugExitSubRule(17); }

                    DebugLocation(189, 85);
                    // AvalonQuery.g3:189:85: ( ':' ( '0' .. '9' )+ ( '.' ( '0' .. '9' )+ )* )*
                    try
                    {
                        DebugEnterSubRule(21);
                        while (true)
                        {
                            int alt21 = 2;
                            try
                            {
                                DebugEnterDecision(21, false);
                                int LA21_1 = input.LA(1);

                                if ((LA21_1 == ':'))
                                {
                                    alt21 = 1;
                                }


                            }
                            finally { DebugExitDecision(21); }
                            switch (alt21)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:189:86: ':' ( '0' .. '9' )+ ( '.' ( '0' .. '9' )+ )*
                                    {
                                        DebugLocation(189, 86);
                                        Match(':');
                                        DebugLocation(189, 93);
                                        // AvalonQuery.g3:189:93: ( '0' .. '9' )+
                                        int cnt18 = 0;
                                        try
                                        {
                                            DebugEnterSubRule(18);
                                            while (true)
                                            {
                                                int alt18 = 2;
                                                try
                                                {
                                                    DebugEnterDecision(18, false);
                                                    int LA18_1 = input.LA(1);

                                                    if (((LA18_1 >= '0' && LA18_1 <= '9')))
                                                    {
                                                        alt18 = 1;
                                                    }


                                                }
                                                finally { DebugExitDecision(18); }
                                                switch (alt18)
                                                {
                                                    case 1:
                                                        DebugEnterAlt(1);
                                                        // AvalonQuery.g3:
                                                        {
                                                            DebugLocation(189, 93);
                                                            input.Consume();


                                                        }
                                                        break;

                                                    default:
                                                        if (cnt18 >= 1)
                                                            goto loop18;

                                                        EarlyExitException eee18 = new EarlyExitException(18, input);
                                                        DebugRecognitionException(eee18);
                                                        throw eee18;
                                                }
                                                cnt18++;
                                            }
                                        loop18:
                                            ;

                                        }
                                        finally { DebugExitSubRule(18); }

                                        DebugLocation(189, 100);
                                        // AvalonQuery.g3:189:100: ( '.' ( '0' .. '9' )+ )*
                                        try
                                        {
                                            DebugEnterSubRule(20);
                                            while (true)
                                            {
                                                int alt20 = 2;
                                                try
                                                {
                                                    DebugEnterDecision(20, false);
                                                    int LA20_1 = input.LA(1);

                                                    if ((LA20_1 == '.'))
                                                    {
                                                        alt20 = 1;
                                                    }


                                                }
                                                finally { DebugExitDecision(20); }
                                                switch (alt20)
                                                {
                                                    case 1:
                                                        DebugEnterAlt(1);
                                                        // AvalonQuery.g3:189:101: '.' ( '0' .. '9' )+
                                                        {
                                                            DebugLocation(189, 101);
                                                            Match('.');
                                                            DebugLocation(189, 108);
                                                            // AvalonQuery.g3:189:108: ( '0' .. '9' )+
                                                            int cnt19 = 0;
                                                            try
                                                            {
                                                                DebugEnterSubRule(19);
                                                                while (true)
                                                                {
                                                                    int alt19 = 2;
                                                                    try
                                                                    {
                                                                        DebugEnterDecision(19, false);
                                                                        int LA19_1 = input.LA(1);

                                                                        if (((LA19_1 >= '0' && LA19_1 <= '9')))
                                                                        {
                                                                            alt19 = 1;
                                                                        }


                                                                    }
                                                                    finally { DebugExitDecision(19); }
                                                                    switch (alt19)
                                                                    {
                                                                        case 1:
                                                                            DebugEnterAlt(1);
                                                                            // AvalonQuery.g3:
                                                                            {
                                                                                DebugLocation(189, 108);
                                                                                input.Consume();


                                                                            }
                                                                            break;

                                                                        default:
                                                                            if (cnt19 >= 1)
                                                                                goto loop19;

                                                                            EarlyExitException eee19 = new EarlyExitException(19, input);
                                                                            DebugRecognitionException(eee19);
                                                                            throw eee19;
                                                                    }
                                                                    cnt19++;
                                                                }
                                                            loop19:
                                                                ;

                                                            }
                                                            finally { DebugExitSubRule(19); }


                                                        }
                                                        break;

                                                    default:
                                                        goto loop20;
                                                }
                                            }

                                        loop20:
                                            ;

                                        }
                                        finally { DebugExitSubRule(20); }


                                    }
                                    break;

                                default:
                                    goto loop21;
                            }
                        }

                    loop21:
                        ;

                    }
                    finally { DebugExitSubRule(21); }

                    DebugLocation(189, 119);
                    Match('\'');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("DATETIME", 40);
                LeaveRule("DATETIME", 40);
                LeaveRule_DATETIME();
            }
        }
        // $ANTLR end "DATETIME"

        partial void EnterRule_GUID();
        partial void LeaveRule_GUID();

        // $ANTLR start "GUID"
        [GrammarRule("GUID")]
        private void mGUID()
        {
            EnterRule_GUID();
            EnterRule("GUID", 41);
            TraceIn("GUID", 41);
            try
            {
                int _type = GUID;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:191:6: ( 'guid\\'' HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR '\\'' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:191:8: 'guid\\'' HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR '\\''
                {
                    DebugLocation(191, 8);
                    Match("guid'");

                    DebugLocation(191, 17);
                    mHEX_PAIR();
                    DebugLocation(191, 26);
                    mHEX_PAIR();
                    DebugLocation(191, 35);
                    mHEX_PAIR();
                    DebugLocation(191, 44);
                    mHEX_PAIR();
                    DebugLocation(191, 53);
                    Match('-');
                    DebugLocation(191, 57);
                    mHEX_PAIR();
                    DebugLocation(191, 66);
                    mHEX_PAIR();
                    DebugLocation(191, 75);
                    Match('-');
                    DebugLocation(191, 79);
                    mHEX_PAIR();
                    DebugLocation(191, 88);
                    mHEX_PAIR();
                    DebugLocation(191, 97);
                    Match('-');
                    DebugLocation(191, 101);
                    mHEX_PAIR();
                    DebugLocation(191, 110);
                    mHEX_PAIR();
                    DebugLocation(191, 119);
                    Match('-');
                    DebugLocation(191, 123);
                    mHEX_PAIR();
                    DebugLocation(191, 132);
                    mHEX_PAIR();
                    DebugLocation(191, 141);
                    mHEX_PAIR();
                    DebugLocation(191, 150);
                    mHEX_PAIR();
                    DebugLocation(191, 159);
                    mHEX_PAIR();
                    DebugLocation(191, 168);
                    mHEX_PAIR();
                    DebugLocation(191, 177);
                    Match('\'');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("GUID", 41);
                LeaveRule("GUID", 41);
                LeaveRule_GUID();
            }
        }
        // $ANTLR end "GUID"

        partial void EnterRule_BYTE();
        partial void LeaveRule_BYTE();

        // $ANTLR start "BYTE"
        [GrammarRule("BYTE")]
        private void mBYTE()
        {
            EnterRule_BYTE();
            EnterRule("BYTE", 42);
            TraceIn("BYTE", 42);
            try
            {
                int _type = BYTE;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:193:6: ( '0x' HEX_PAIR )
                DebugEnterAlt(1);
                // AvalonQuery.g3:193:8: '0x' HEX_PAIR
                {
                    DebugLocation(193, 8);
                    Match("0x");

                    DebugLocation(193, 13);
                    mHEX_PAIR();

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("BYTE", 42);
                LeaveRule("BYTE", 42);
                LeaveRule_BYTE();
            }
        }
        // $ANTLR end "BYTE"

        partial void EnterRule_SPACE();
        partial void LeaveRule_SPACE();

        // $ANTLR start "SPACE"
        [GrammarRule("SPACE")]
        private void mSPACE()
        {
            EnterRule_SPACE();
            EnterRule("SPACE", 43);
            TraceIn("SPACE", 43);
            try
            {
                int _type = SPACE;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:195:7: ( ( ' ' | '\\t' )+ )
                DebugEnterAlt(1);
                // AvalonQuery.g3:195:9: ( ' ' | '\\t' )+
                {
                    DebugLocation(195, 9);
                    // AvalonQuery.g3:195:9: ( ' ' | '\\t' )+
                    int cnt22 = 0;
                    try
                    {
                        DebugEnterSubRule(22);
                        while (true)
                        {
                            int alt22 = 2;
                            try
                            {
                                DebugEnterDecision(22, false);
                                int LA22_1 = input.LA(1);

                                if ((LA22_1 == '\t' || LA22_1 == ' '))
                                {
                                    alt22 = 1;
                                }


                            }
                            finally { DebugExitDecision(22); }
                            switch (alt22)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(195, 9);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt22 >= 1)
                                        goto loop22;

                                    EarlyExitException eee22 = new EarlyExitException(22, input);
                                    DebugRecognitionException(eee22);
                                    throw eee22;
                            }
                            cnt22++;
                        }
                    loop22:
                        ;

                    }
                    finally { DebugExitSubRule(22); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("SPACE", 43);
                LeaveRule("SPACE", 43);
                LeaveRule_SPACE();
            }
        }
        // $ANTLR end "SPACE"

        partial void EnterRule_NEWLINE();
        partial void LeaveRule_NEWLINE();

        // $ANTLR start "NEWLINE"
        [GrammarRule("NEWLINE")]
        private void mNEWLINE()
        {
            EnterRule_NEWLINE();
            EnterRule("NEWLINE", 44);
            TraceIn("NEWLINE", 44);
            try
            {
                int _type = NEWLINE;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:197:9: ( ( '\\r' | '\\n' )+ )
                DebugEnterAlt(1);
                // AvalonQuery.g3:197:11: ( '\\r' | '\\n' )+
                {
                    DebugLocation(197, 11);
                    // AvalonQuery.g3:197:11: ( '\\r' | '\\n' )+
                    int cnt23 = 0;
                    try
                    {
                        DebugEnterSubRule(23);
                        while (true)
                        {
                            int alt23 = 2;
                            try
                            {
                                DebugEnterDecision(23, false);
                                int LA23_1 = input.LA(1);

                                if ((LA23_1 == '\n' || LA23_1 == '\r'))
                                {
                                    alt23 = 1;
                                }


                            }
                            finally { DebugExitDecision(23); }
                            switch (alt23)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(197, 11);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt23 >= 1)
                                        goto loop23;

                                    EarlyExitException eee23 = new EarlyExitException(23, input);
                                    DebugRecognitionException(eee23);
                                    throw eee23;
                            }
                            cnt23++;
                        }
                    loop23:
                        ;

                    }
                    finally { DebugExitSubRule(23); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("NEWLINE", 44);
                LeaveRule("NEWLINE", 44);
                LeaveRule_NEWLINE();
            }
        }
        // $ANTLR end "NEWLINE"

        partial void EnterRule_HEX_PAIR();
        partial void LeaveRule_HEX_PAIR();

        // $ANTLR start "HEX_PAIR"
        [GrammarRule("HEX_PAIR")]
        private void mHEX_PAIR()
        {
            EnterRule_HEX_PAIR();
            EnterRule("HEX_PAIR", 45);
            TraceIn("HEX_PAIR", 45);
            try
            {
                // AvalonQuery.g3:202:2: ( HEX_DIGIT HEX_DIGIT )
                DebugEnterAlt(1);
                // AvalonQuery.g3:202:4: HEX_DIGIT HEX_DIGIT
                {
                    DebugLocation(202, 4);
                    mHEX_DIGIT();
                    DebugLocation(202, 14);
                    mHEX_DIGIT();

                }

            }
            finally
            {
                TraceOut("HEX_PAIR", 45);
                LeaveRule("HEX_PAIR", 45);
                LeaveRule_HEX_PAIR();
            }
        }
        // $ANTLR end "HEX_PAIR"

        partial void EnterRule_IDENTIFIER();
        partial void LeaveRule_IDENTIFIER();

        // $ANTLR start "IDENTIFIER"
        [GrammarRule("IDENTIFIER")]
        private void mIDENTIFIER()
        {
            EnterRule_IDENTIFIER();
            EnterRule("IDENTIFIER", 46);
            TraceIn("IDENTIFIER", 46);
            try
            {
                int _type = IDENTIFIER;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:204:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )+ )
                DebugEnterAlt(1);
                // AvalonQuery.g3:204:4: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )+
                {
                    DebugLocation(204, 4);
                    // AvalonQuery.g3:204:4: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )+
                    int cnt24 = 0;
                    try
                    {
                        DebugEnterSubRule(24);
                        while (true)
                        {
                            int alt24 = 2;
                            try
                            {
                                DebugEnterDecision(24, false);
                                int LA24_1 = input.LA(1);

                                if (((LA24_1 >= '0' && LA24_1 <= '9') || (LA24_1 >= 'A' && LA24_1 <= 'Z') || LA24_1 == '_' || (LA24_1 >= 'a' && LA24_1 <= 'z')))
                                {
                                    alt24 = 1;
                                }


                            }
                            finally { DebugExitDecision(24); }
                            switch (alt24)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:
                                    {
                                        DebugLocation(204, 4);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    if (cnt24 >= 1)
                                        goto loop24;

                                    EarlyExitException eee24 = new EarlyExitException(24, input);
                                    DebugRecognitionException(eee24);
                                    throw eee24;
                            }
                            cnt24++;
                        }
                    loop24:
                        ;

                    }
                    finally { DebugExitSubRule(24); }


                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("IDENTIFIER", 46);
                LeaveRule("IDENTIFIER", 46);
                LeaveRule_IDENTIFIER();
            }
        }
        // $ANTLR end "IDENTIFIER"

        partial void EnterRule_STRING();
        partial void LeaveRule_STRING();

        // $ANTLR start "STRING"
        [GrammarRule("STRING")]
        private void mSTRING()
        {
            EnterRule_STRING();
            EnterRule("STRING", 47);
            TraceIn("STRING", 47);
            try
            {
                int _type = STRING;
                int _channel = DefaultTokenChannel;
                // AvalonQuery.g3:206:9: ( '\\'' ( ESC_SEQ |~ ( '\\\\' | '\\'' ) )* '\\'' )
                DebugEnterAlt(1);
                // AvalonQuery.g3:206:12: '\\'' ( ESC_SEQ |~ ( '\\\\' | '\\'' ) )* '\\''
                {
                    DebugLocation(206, 12);
                    Match('\'');
                    DebugLocation(206, 17);
                    // AvalonQuery.g3:206:17: ( ESC_SEQ |~ ( '\\\\' | '\\'' ) )*
                    try
                    {
                        DebugEnterSubRule(25);
                        while (true)
                        {
                            int alt25 = 3;
                            try
                            {
                                DebugEnterDecision(25, false);
                                int LA25_1 = input.LA(1);

                                if ((LA25_1 == '\''))
                                {
                                    int LA25_2 = input.LA(2);

                                    if ((LA25_2 == '\''))
                                    {
                                        alt25 = 1;
                                    }


                                }
                                else if ((LA25_1 == '\\'))
                                {
                                    alt25 = 1;
                                }
                                else if (((LA25_1 >= '\u0000' && LA25_1 <= '&') || (LA25_1 >= '(' && LA25_1 <= '[') || (LA25_1 >= ']' && LA25_1 <= '\uFFFF')))
                                {
                                    alt25 = 2;
                                }


                            }
                            finally { DebugExitDecision(25); }
                            switch (alt25)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // AvalonQuery.g3:206:18: ESC_SEQ
                                    {
                                        DebugLocation(206, 18);
                                        mESC_SEQ();

                                    }
                                    break;
                                case 2:
                                    DebugEnterAlt(2);
                                    // AvalonQuery.g3:206:27: ~ ( '\\\\' | '\\'' )
                                    {
                                        DebugLocation(206, 27);
                                        input.Consume();


                                    }
                                    break;

                                default:
                                    goto loop25;
                            }
                        }

                    loop25:
                        ;

                    }
                    finally { DebugExitSubRule(25); }

                    DebugLocation(206, 42);
                    Match('\'');

                }

                state.type = _type;
                state.channel = _channel;
            }
            finally
            {
                TraceOut("STRING", 47);
                LeaveRule("STRING", 47);
                LeaveRule_STRING();
            }
        }
        // $ANTLR end "STRING"

        partial void EnterRule_HEX_DIGIT();
        partial void LeaveRule_HEX_DIGIT();

        // $ANTLR start "HEX_DIGIT"
        [GrammarRule("HEX_DIGIT")]
        private void mHEX_DIGIT()
        {
            EnterRule_HEX_DIGIT();
            EnterRule("HEX_DIGIT", 48);
            TraceIn("HEX_DIGIT", 48);
            try
            {
                // AvalonQuery.g3:210:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
                DebugEnterAlt(1);
                // AvalonQuery.g3:
                {
                    DebugLocation(210, 11);
                    if ((input.LA(1) >= '0' && input.LA(1) <= '9') || (input.LA(1) >= 'A' && input.LA(1) <= 'F') || (input.LA(1) >= 'a' && input.LA(1) <= 'f'))
                    {
                        input.Consume();
                    }
                    else
                    {
                        MismatchedSetException mse = new MismatchedSetException(null, input);
                        DebugRecognitionException(mse);
                        Recover(mse);
                        throw mse;
                    }


                }

            }
            finally
            {
                TraceOut("HEX_DIGIT", 48);
                LeaveRule("HEX_DIGIT", 48);
                LeaveRule_HEX_DIGIT();
            }
        }
        // $ANTLR end "HEX_DIGIT"

        partial void EnterRule_ESC_SEQ();
        partial void LeaveRule_ESC_SEQ();

        // $ANTLR start "ESC_SEQ"
        [GrammarRule("ESC_SEQ")]
        private void mESC_SEQ()
        {
            EnterRule_ESC_SEQ();
            EnterRule("ESC_SEQ", 49);
            TraceIn("ESC_SEQ", 49);
            try
            {
                // AvalonQuery.g3:214:2: ( '\\'\\'' | '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )
                int alt26 = 4;
                try
                {
                    DebugEnterDecision(26, false);
                    int LA26_1 = input.LA(1);

                    if ((LA26_1 == '\''))
                    {
                        alt26 = 1;
                    }
                    else if ((LA26_1 == '\\'))
                    {
                        switch (input.LA(2))
                        {
                            case '\"':
                            case '\'':
                            case '\\':
                            case 'b':
                            case 'f':
                            case 'n':
                            case 'r':
                            case 't':
                                {
                                    alt26 = 2;
                                }
                                break;
                            case 'u':
                                {
                                    alt26 = 3;
                                }
                                break;
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                                {
                                    alt26 = 4;
                                }
                                break;
                            default:
                                {
                                    NoViableAltException nvae = new NoViableAltException("", 26, 2, input, 2);
                                    DebugRecognitionException(nvae);
                                    throw nvae;
                                }
                        }

                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(26); }
                switch (alt26)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // AvalonQuery.g3:214:4: '\\'\\''
                        {
                            DebugLocation(214, 4);
                            Match("''");


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // AvalonQuery.g3:215:5: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
                        {
                            DebugLocation(215, 5);
                            Match('\\');
                            DebugLocation(215, 10);
                            input.Consume();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // AvalonQuery.g3:216:5: UNICODE_ESC
                        {
                            DebugLocation(216, 5);
                            mUNICODE_ESC();

                        }
                        break;
                    case 4:
                        DebugEnterAlt(4);
                        // AvalonQuery.g3:217:5: OCTAL_ESC
                        {
                            DebugLocation(217, 5);
                            mOCTAL_ESC();

                        }
                        break;

                }
            }
            finally
            {
                TraceOut("ESC_SEQ", 49);
                LeaveRule("ESC_SEQ", 49);
                LeaveRule_ESC_SEQ();
            }
        }
        // $ANTLR end "ESC_SEQ"

        partial void EnterRule_OCTAL_ESC();
        partial void LeaveRule_OCTAL_ESC();

        // $ANTLR start "OCTAL_ESC"
        [GrammarRule("OCTAL_ESC")]
        private void mOCTAL_ESC()
        {
            EnterRule_OCTAL_ESC();
            EnterRule("OCTAL_ESC", 50);
            TraceIn("OCTAL_ESC", 50);
            try
            {
                // AvalonQuery.g3:222:3: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
                int alt27 = 3;
                try
                {
                    DebugEnterDecision(27, false);
                    int LA27_1 = input.LA(1);

                    if ((LA27_1 == '\\'))
                    {
                        int LA27_2 = input.LA(2);

                        if (((LA27_2 >= '0' && LA27_2 <= '3')))
                        {
                            int LA27_3 = input.LA(3);

                            if (((LA27_3 >= '0' && LA27_3 <= '7')))
                            {
                                int LA27_4 = input.LA(4);

                                if (((LA27_4 >= '0' && LA27_4 <= '7')))
                                {
                                    alt27 = 1;
                                }
                                else
                                {
                                    alt27 = 2;
                                }
                            }
                            else
                            {
                                alt27 = 3;
                            }
                        }
                        else if (((LA27_2 >= '4' && LA27_2 <= '7')))
                        {
                            int LA27_3 = input.LA(3);

                            if (((LA27_3 >= '0' && LA27_3 <= '7')))
                            {
                                alt27 = 2;
                            }
                            else
                            {
                                alt27 = 3;
                            }
                        }
                        else
                        {
                            NoViableAltException nvae = new NoViableAltException("", 27, 1, input, 2);
                            DebugRecognitionException(nvae);
                            throw nvae;
                        }
                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(27); }
                switch (alt27)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // AvalonQuery.g3:222:7: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
                        {
                            DebugLocation(222, 7);
                            Match('\\');
                            DebugLocation(222, 12);
                            input.Consume();

                            DebugLocation(222, 23);
                            input.Consume();

                            DebugLocation(222, 34);
                            input.Consume();


                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // AvalonQuery.g3:223:7: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
                        {
                            DebugLocation(223, 7);
                            Match('\\');
                            DebugLocation(223, 12);
                            input.Consume();

                            DebugLocation(223, 23);
                            input.Consume();


                        }
                        break;
                    case 3:
                        DebugEnterAlt(3);
                        // AvalonQuery.g3:224:7: '\\\\' ( '0' .. '7' )
                        {
                            DebugLocation(224, 7);
                            Match('\\');
                            DebugLocation(224, 12);
                            input.Consume();


                        }
                        break;

                }
            }
            finally
            {
                TraceOut("OCTAL_ESC", 50);
                LeaveRule("OCTAL_ESC", 50);
                LeaveRule_OCTAL_ESC();
            }
        }
        // $ANTLR end "OCTAL_ESC"

        partial void EnterRule_UNICODE_ESC();
        partial void LeaveRule_UNICODE_ESC();

        // $ANTLR start "UNICODE_ESC"
        [GrammarRule("UNICODE_ESC")]
        private void mUNICODE_ESC()
        {
            EnterRule_UNICODE_ESC();
            EnterRule("UNICODE_ESC", 51);
            TraceIn("UNICODE_ESC", 51);
            try
            {
                // AvalonQuery.g3:229:3: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
                DebugEnterAlt(1);
                // AvalonQuery.g3:229:7: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
                {
                    DebugLocation(229, 7);
                    Match('\\');
                    DebugLocation(229, 12);
                    Match('u');
                    DebugLocation(229, 16);
                    mHEX_DIGIT();
                    DebugLocation(229, 26);
                    mHEX_DIGIT();
                    DebugLocation(229, 36);
                    mHEX_DIGIT();
                    DebugLocation(229, 46);
                    mHEX_DIGIT();

                }

            }
            finally
            {
                TraceOut("UNICODE_ESC", 51);
                LeaveRule("UNICODE_ESC", 51);
                LeaveRule_UNICODE_ESC();
            }
        }
        // $ANTLR end "UNICODE_ESC"

        public override void mTokens()
        {
            // AvalonQuery.g3:1:8: ( T__51 | T__52 | T__53 | T__54 | IN | NOTIN | EQUALS | NOTEQUALS | GREATERTHAN | GREATERTHANOREQUAL | LESSTHAN | LESSTHANOREQUAL | NOT | OR | AND | ASC | DESC | ALLPAGES | NONE | SKIP | TOP | FILTER | ORDERBY | SELECT | INLINECOUNT | COUNT | STARTSWITH | ENDSWITH | SUBSTRINGOF | MIN | MAX | SUM | AVERAGE | INT | LONG | DOUBLE | SINGLE | BOOL | NULL | DATETIME | GUID | BYTE | SPACE | NEWLINE | IDENTIFIER | STRING )
            int alt28 = 46;
            try
            {
                DebugEnterDecision(28, false);
                try
                {
                    alt28 = dfa28.Predict(input);
                }
                catch (NoViableAltException nvae)
                {
                    DebugRecognitionException(nvae);
                    throw;
                }
            }
            finally { DebugExitDecision(28); }
            switch (alt28)
            {
                case 1:
                    DebugEnterAlt(1);
                    // AvalonQuery.g3:1:10: T__51
                    {
                        DebugLocation(1, 10);
                        mT__51();

                    }
                    break;
                case 2:
                    DebugEnterAlt(2);
                    // AvalonQuery.g3:1:16: T__52
                    {
                        DebugLocation(1, 16);
                        mT__52();

                    }
                    break;
                case 3:
                    DebugEnterAlt(3);
                    // AvalonQuery.g3:1:22: T__53
                    {
                        DebugLocation(1, 22);
                        mT__53();

                    }
                    break;
                case 4:
                    DebugEnterAlt(4);
                    // AvalonQuery.g3:1:28: T__54
                    {
                        DebugLocation(1, 28);
                        mT__54();

                    }
                    break;
                case 5:
                    DebugEnterAlt(5);
                    // AvalonQuery.g3:1:34: IN
                    {
                        DebugLocation(1, 34);
                        mIN();

                    }
                    break;
                case 6:
                    DebugEnterAlt(6);
                    // AvalonQuery.g3:1:37: NOTIN
                    {
                        DebugLocation(1, 37);
                        mNOTIN();

                    }
                    break;
                case 7:
                    DebugEnterAlt(7);
                    // AvalonQuery.g3:1:43: EQUALS
                    {
                        DebugLocation(1, 43);
                        mEQUALS();

                    }
                    break;
                case 8:
                    DebugEnterAlt(8);
                    // AvalonQuery.g3:1:50: NOTEQUALS
                    {
                        DebugLocation(1, 50);
                        mNOTEQUALS();

                    }
                    break;
                case 9:
                    DebugEnterAlt(9);
                    // AvalonQuery.g3:1:60: GREATERTHAN
                    {
                        DebugLocation(1, 60);
                        mGREATERTHAN();

                    }
                    break;
                case 10:
                    DebugEnterAlt(10);
                    // AvalonQuery.g3:1:72: GREATERTHANOREQUAL
                    {
                        DebugLocation(1, 72);
                        mGREATERTHANOREQUAL();

                    }
                    break;
                case 11:
                    DebugEnterAlt(11);
                    // AvalonQuery.g3:1:91: LESSTHAN
                    {
                        DebugLocation(1, 91);
                        mLESSTHAN();

                    }
                    break;
                case 12:
                    DebugEnterAlt(12);
                    // AvalonQuery.g3:1:100: LESSTHANOREQUAL
                    {
                        DebugLocation(1, 100);
                        mLESSTHANOREQUAL();

                    }
                    break;
                case 13:
                    DebugEnterAlt(13);
                    // AvalonQuery.g3:1:116: NOT
                    {
                        DebugLocation(1, 116);
                        mNOT();

                    }
                    break;
                case 14:
                    DebugEnterAlt(14);
                    // AvalonQuery.g3:1:120: OR
                    {
                        DebugLocation(1, 120);
                        mOR();

                    }
                    break;
                case 15:
                    DebugEnterAlt(15);
                    // AvalonQuery.g3:1:123: AND
                    {
                        DebugLocation(1, 123);
                        mAND();

                    }
                    break;
                case 16:
                    DebugEnterAlt(16);
                    // AvalonQuery.g3:1:127: ASC
                    {
                        DebugLocation(1, 127);
                        mASC();

                    }
                    break;
                case 17:
                    DebugEnterAlt(17);
                    // AvalonQuery.g3:1:131: DESC
                    {
                        DebugLocation(1, 131);
                        mDESC();

                    }
                    break;
                case 18:
                    DebugEnterAlt(18);
                    // AvalonQuery.g3:1:136: ALLPAGES
                    {
                        DebugLocation(1, 136);
                        mALLPAGES();

                    }
                    break;
                case 19:
                    DebugEnterAlt(19);
                    // AvalonQuery.g3:1:145: NONE
                    {
                        DebugLocation(1, 145);
                        mNONE();

                    }
                    break;
                case 20:
                    DebugEnterAlt(20);
                    // AvalonQuery.g3:1:150: SKIP
                    {
                        DebugLocation(1, 150);
                        mSKIP();

                    }
                    break;
                case 21:
                    DebugEnterAlt(21);
                    // AvalonQuery.g3:1:155: TOP
                    {
                        DebugLocation(1, 155);
                        mTOP();

                    }
                    break;
                case 22:
                    DebugEnterAlt(22);
                    // AvalonQuery.g3:1:159: FILTER
                    {
                        DebugLocation(1, 159);
                        mFILTER();

                    }
                    break;
                case 23:
                    DebugEnterAlt(23);
                    // AvalonQuery.g3:1:166: ORDERBY
                    {
                        DebugLocation(1, 166);
                        mORDERBY();

                    }
                    break;
                case 24:
                    DebugEnterAlt(24);
                    // AvalonQuery.g3:1:174: SELECT
                    {
                        DebugLocation(1, 174);
                        mSELECT();

                    }
                    break;
                case 25:
                    DebugEnterAlt(25);
                    // AvalonQuery.g3:1:181: INLINECOUNT
                    {
                        DebugLocation(1, 181);
                        mINLINECOUNT();

                    }
                    break;
                case 26:
                    DebugEnterAlt(26);
                    // AvalonQuery.g3:1:193: COUNT
                    {
                        DebugLocation(1, 193);
                        mCOUNT();

                    }
                    break;
                case 27:
                    DebugEnterAlt(27);
                    // AvalonQuery.g3:1:199: STARTSWITH
                    {
                        DebugLocation(1, 199);
                        mSTARTSWITH();

                    }
                    break;
                case 28:
                    DebugEnterAlt(28);
                    // AvalonQuery.g3:1:210: ENDSWITH
                    {
                        DebugLocation(1, 210);
                        mENDSWITH();

                    }
                    break;
                case 29:
                    DebugEnterAlt(29);
                    // AvalonQuery.g3:1:219: SUBSTRINGOF
                    {
                        DebugLocation(1, 219);
                        mSUBSTRINGOF();

                    }
                    break;
                case 30:
                    DebugEnterAlt(30);
                    // AvalonQuery.g3:1:231: MIN
                    {
                        DebugLocation(1, 231);
                        mMIN();

                    }
                    break;
                case 31:
                    DebugEnterAlt(31);
                    // AvalonQuery.g3:1:235: MAX
                    {
                        DebugLocation(1, 235);
                        mMAX();

                    }
                    break;
                case 32:
                    DebugEnterAlt(32);
                    // AvalonQuery.g3:1:239: SUM
                    {
                        DebugLocation(1, 239);
                        mSUM();

                    }
                    break;
                case 33:
                    DebugEnterAlt(33);
                    // AvalonQuery.g3:1:243: AVERAGE
                    {
                        DebugLocation(1, 243);
                        mAVERAGE();

                    }
                    break;
                case 34:
                    DebugEnterAlt(34);
                    // AvalonQuery.g3:1:251: INT
                    {
                        DebugLocation(1, 251);
                        mINT();

                    }
                    break;
                case 35:
                    DebugEnterAlt(35);
                    // AvalonQuery.g3:1:255: LONG
                    {
                        DebugLocation(1, 255);
                        mLONG();

                    }
                    break;
                case 36:
                    DebugEnterAlt(36);
                    // AvalonQuery.g3:1:260: DOUBLE
                    {
                        DebugLocation(1, 260);
                        mDOUBLE();

                    }
                    break;
                case 37:
                    DebugEnterAlt(37);
                    // AvalonQuery.g3:1:267: SINGLE
                    {
                        DebugLocation(1, 267);
                        mSINGLE();

                    }
                    break;
                case 38:
                    DebugEnterAlt(38);
                    // AvalonQuery.g3:1:274: BOOL
                    {
                        DebugLocation(1, 274);
                        mBOOL();

                    }
                    break;
                case 39:
                    DebugEnterAlt(39);
                    // AvalonQuery.g3:1:279: NULL
                    {
                        DebugLocation(1, 279);
                        mNULL();

                    }
                    break;
                case 40:
                    DebugEnterAlt(40);
                    // AvalonQuery.g3:1:284: DATETIME
                    {
                        DebugLocation(1, 284);
                        mDATETIME();

                    }
                    break;
                case 41:
                    DebugEnterAlt(41);
                    // AvalonQuery.g3:1:293: GUID
                    {
                        DebugLocation(1, 293);
                        mGUID();

                    }
                    break;
                case 42:
                    DebugEnterAlt(42);
                    // AvalonQuery.g3:1:298: BYTE
                    {
                        DebugLocation(1, 298);
                        mBYTE();

                    }
                    break;
                case 43:
                    DebugEnterAlt(43);
                    // AvalonQuery.g3:1:303: SPACE
                    {
                        DebugLocation(1, 303);
                        mSPACE();

                    }
                    break;
                case 44:
                    DebugEnterAlt(44);
                    // AvalonQuery.g3:1:309: NEWLINE
                    {
                        DebugLocation(1, 309);
                        mNEWLINE();

                    }
                    break;
                case 45:
                    DebugEnterAlt(45);
                    // AvalonQuery.g3:1:317: IDENTIFIER
                    {
                        DebugLocation(1, 317);
                        mIDENTIFIER();

                    }
                    break;
                case 46:
                    DebugEnterAlt(46);
                    // AvalonQuery.g3:1:328: STRING
                    {
                        DebugLocation(1, 328);
                        mSTRING();

                    }
                    break;

            }

        }


        #region DFA
        DFA28 dfa28;

        protected override void InitDFAs()
        {
            base.InitDFAs();
            dfa28 = new DFA28(this);
        }

        private class DFA28 : DFA
        {
            private const string DFA28_eotS =
                "\x5\xFFFF\x8\x17\x1\xFFFF\x2\x17\x1\xFFFF\x1\x37\x2\x17\x1\x37\x4\xFFFF" +
                "\x1\x3C\x1\x17\x1\x3F\x1\x17\x1\x41\x1\x17\x1\x43\x1\x44\x1\x17\x1\x46" +
                "\x1\x47\x1\x48\x6\x17\x6\xFFFF\x4\x17\x1\x37\x1\x17\x1\xFFFF\x1\x56\x1" +
                "\xFFFF\x2\x17\x1\xFFFF\x1\x5C\x1\x17\x1\xFFFF\x1\x17\x1\xFFFF\x1\x17" +
                "\x2\xFFFF\x1\x17\x3\xFFFF\x1\x61\x1\x62\x4\x17\x2\xFFFF\x2\x17\x1\x69" +
                "\x1\x6A\x1\x6B\x1\xFFFF\x1\x17\x1\x6D\x3\x17\x1\xFFFF\x1\x72\x1\x73\x2" +
                "\x17\x2\xFFFF\x2\x17\x1\x78\x3\x17\x3\xFFFF\x1\x7C\x2\xFFFF\x1\x7D\x1" +
                "\x17\x1\x7F\x2\xFFFF\x1\x17\x1\xFFFF\x2\x17\x1\xFFFF\x3\x17\x2\xFFFF" +
                "\x1\x7D\x1\xFFFF\x8\x17\x1\x8E\x3\x17\x1\x92\x1\x93\x1\xFFFF\x3\x17\x3" +
                "\xFFFF\x2\x17\x1\x99\x1\x17\x1\xFFFF\x1\x9B\x1\xFFFF";
            private const string DFA28_eofS =
                "\x9C\xFFFF";
            private const string DFA28_minS =
                "\x1\x9\x4\xFFFF\x1\x6E\x1\x65\x1\x6E\x2\x65\x1\x72\x1\x6C\x1\x61\x1\x63" +
                "\x1\x74\x1\x61\x1\x30\x1\x2E\x1\x72\x1\x61\x1\x2E\x4\xFFFF\x1\x30\x1" +
                "\x6E\x1\x30\x1\x6C\x1\x30\x1\x64\x2\x30\x1\x69\x3\x30\x1\x64\x1\x63\x1" +
                "\x6C\x1\x65\x1\x73\x1\x74\x1\x65\x5\xFFFF\x1\x61\x1\x62\x1\x6E\x1\x78" +
                "\x1\x2E\x1\x30\x1\xFFFF\x2\x30\x1\x75\x1\x6C\x1\xFFFF\x1\x30\x1\x65\x1" +
                "\xFFFF\x1\x6C\x1\xFFFF\x1\x73\x2\xFFFF\x1\x64\x3\xFFFF\x2\x30\x1\x70" +
                "\x1\x72\x1\x63\x1\x65\x2\xFFFF\x1\x72\x1\x73\x3\x30\x1\xFFFF\x2\x30\x1" +
                "\x65\x1\x73\x1\x6E\x1\xFFFF\x2\x30\x1\x77\x1\x27\x2\xFFFF\x2\x61\x1\x30" +
                "\x3\x74\x3\xFFFF\x1\x30\x2\xFFFF\x1\x30\x1\x65\x1\x30\x2\xFFFF\x1\x69" +
                "\x1\xFFFF\x2\x67\x1\xFFFF\x1\x69\x1\x73\x1\x72\x2\xFFFF\x1\x30\x1\xFFFF" +
                "\x1\x74\x2\x65\x1\x6D\x1\x77\x1\x69\x1\x68\x1\x73\x1\x30\x1\x65\x1\x69" +
                "\x1\x6E\x2\x30\x1\xFFFF\x1\x27\x1\x74\x1\x67\x3\xFFFF\x1\x68\x1\x6F\x1" +
                "\x30\x1\x66\x1\xFFFF\x1\x30\x1\xFFFF";
            private const string DFA28_maxS =
                "\x1\x7A\x4\xFFFF\x1\x6E\x1\x75\x1\x71\x1\x75\x1\x74\x1\x72\x1\x76\x1" +
                "\x65\x1\x74\x1\x75\x1\x69\x1\x39\x1\x7A\x1\x72\x1\x61\x1\x7A\x4\xFFFF" +
                "\x1\x7A\x1\x74\x1\x7A\x1\x6C\x1\x7A\x1\x64\x2\x7A\x1\x69\x3\x7A\x1\x64" +
                "\x1\x63\x1\x6C\x1\x65\x1\x73\x1\x74\x1\x6B\x5\xFFFF\x1\x61\x1\x6D\x1" +
                "\x6E\x1\x78\x1\x4C\x1\x66\x1\xFFFF\x1\x7A\x1\x39\x1\x75\x1\x6C\x1\xFFFF" +
                "\x1\x7A\x1\x65\x1\xFFFF\x1\x6C\x1\xFFFF\x1\x73\x2\xFFFF\x1\x64\x3\xFFFF" +
                "\x2\x7A\x1\x70\x1\x72\x1\x63\x1\x65\x2\xFFFF\x1\x72\x1\x73\x3\x7A\x1" +
                "\xFFFF\x2\x66\x1\x65\x1\x73\x1\x6E\x1\xFFFF\x2\x7A\x1\x77\x1\x27\x2\xFFFF" +
                "\x2\x61\x1\x7A\x3\x74\x3\xFFFF\x1\x7A\x2\xFFFF\x1\x7A\x1\x65\x1\x7A\x2" +
                "\xFFFF\x1\x69\x1\xFFFF\x2\x67\x1\xFFFF\x1\x69\x1\x73\x1\x72\x2\xFFFF" +
                "\x1\x7A\x1\xFFFF\x1\x74\x2\x65\x1\x6D\x1\x77\x1\x69\x1\x68\x1\x73\x1" +
                "\x7A\x1\x65\x1\x69\x1\x6E\x2\x7A\x1\xFFFF\x1\x27\x1\x74\x1\x67\x3\xFFFF" +
                "\x1\x68\x1\x6F\x1\x7A\x1\x66\x1\xFFFF\x1\x7A\x1\xFFFF";
            private const string DFA28_acceptS =
                "\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x10\xFFFF\x1\x2B\x1\x2C\x1\x2D\x1\x2E" +
                "\x13\xFFFF\x1\x15\x1\x16\x1\x17\x1\x19\x1\x1A\x6\xFFFF\x1\x22\x4\xFFFF" +
                "\x1\x5\x2\xFFFF\x1\x8\x1\xFFFF\x1\x7\x1\xFFFF\x1\x9\x1\xA\x1\xFFFF\x1" +
                "\xB\x1\xC\x1\xE\x6\xFFFF\x1\x14\x1\x18\x5\xFFFF\x1\x23\x5\xFFFF\x1\xD" +
                "\x4\xFFFF\x1\xF\x1\x10\x6\xFFFF\x1\x20\x1\x1E\x1\x1F\x1\xFFFF\x1\x24" +
                "\x1\x25\x3\xFFFF\x1\x13\x1\x27\x1\xFFFF\x1\x29\x2\xFFFF\x1\x11\x3\xFFFF" +
                "\x1\x2A\x1\x26\x1\xFFFF\x1\x6\xE\xFFFF\x1\x21\x3\xFFFF\x1\x1C\x1\x12" +
                "\x1\x28\x4\xFFFF\x1\x1B\x1\xFFFF\x1\x1D";
            private const string DFA28_specialS =
                "\x9C\xFFFF}>";
            private static readonly string[] DFA28_transitionS =
			{
				"\x1\x15\x1\x16\x2\xFFFF\x1\x16\x12\xFFFF\x1\x15\x3\xFFFF\x1\xD\x1\xFFFF"+
				"\x1\x1\x1\x18\x1\x2\x1\x3\x2\xFFFF\x1\x4\x1\x10\x2\xFFFF\x1\x11\x9\x14"+
				"\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1\xB\x2\x17\x1\xC\x1\x7"+
				"\x1\x13\x1\x8\x1\x17\x1\x5\x2\x17\x1\x9\x1\xF\x1\x6\x1\xA\x3\x17\x1"+
				"\xE\x1\x12\x6\x17",
				"",
				"",
				"",
				"",
				"\x1\x19",
				"\x1\x1B\x9\xFFFF\x1\x1A\x5\xFFFF\x1\x1C",
				"\x1\x1E\x2\xFFFF\x1\x1D",
				"\x1\x20\xE\xFFFF\x1\x1F\x1\x21",
				"\x1\x23\xE\xFFFF\x1\x22",
				"\x1\x24",
				"\x1\x27\x1\xFFFF\x1\x25\x4\xFFFF\x1\x26\x2\xFFFF\x1\x28",
				"\x1\x2A\x3\xFFFF\x1\x29",
				"\x1\x30\x2\xFFFF\x1\x2D\x2\xFFFF\x1\x2F\x5\xFFFF\x1\x2E\x3\xFFFF\x1"+
				"\x2B\x1\x2C",
				"\x1\x31\x1\x32",
				"\x1\x34\x7\xFFFF\x1\x33",
				"\xA\x35",
				"\x1\x39\x1\xFFFF\xA\x14\x7\xFFFF\xB\x17\x1\x38\xE\x17\x4\xFFFF\x1\x17"+
				"\x1\xFFFF\x17\x17\x1\x36\x2\x17",
				"\x1\x3A",
				"\x1\x3B",
				"\x1\x39\x1\xFFFF\xA\x14\x7\xFFFF\xB\x17\x1\x38\xE\x17\x4\xFFFF\x1\x17"+
				"\x1\xFFFF\x1A\x17",
				"",
				"",
				"",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x3E\x5\xFFFF\x1\x3D",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x40",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x42",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x45",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x49",
				"\x1\x4A",
				"\x1\x4B",
				"\x1\x4C",
				"\x1\x4D",
				"\x1\x4E",
				"\x1\x50\x5\xFFFF\x1\x4F",
				"",
				"",
				"",
				"",
				"",
				"\x1\x51",
				"\x1\x52\xA\xFFFF\x1\x53",
				"\x1\x54",
				"\x1\x55",
				"\x1\x39\x1\xFFFF\xA\x35\x12\xFFFF\x1\x56",
				"\xA\x57\x7\xFFFF\x6\x57\x1A\xFFFF\x6\x57",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x58",
				"\x1\x59",
				"\x1\x5A",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x8\x17\x1\x5B\x11"+
				"\x17",
				"\x1\x5D",
				"",
				"\x1\x5E",
				"",
				"\x1\x5F",
				"",
				"",
				"\x1\x60",
				"",
				"",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x63",
				"\x1\x64",
				"\x1\x65",
				"\x1\x66",
				"",
				"",
				"\x1\x67",
				"\x1\x68",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"",
				"\xA\x6C\x7\xFFFF\x6\x6C\x1A\xFFFF\x6\x6C",
				"\xA\x58\x2C\xFFFF\x1\x6E",
				"\x1\x6F",
				"\x1\x70",
				"\x1\x71",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x74",
				"\x1\x75",
				"",
				"",
				"\x1\x76",
				"\x1\x77",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x79",
				"\x1\x7A",
				"\x1\x7B",
				"",
				"",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x7E",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"",
				"",
				"\x1\x80",
				"",
				"\x1\x81",
				"\x1\x82",
				"",
				"\x1\x83",
				"\x1\x84",
				"\x1\x85",
				"",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"",
				"\x1\x86",
				"\x1\x87",
				"\x1\x88",
				"\x1\x89",
				"\x1\x8A",
				"\x1\x8B",
				"\x1\x8C",
				"\x1\x8D",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x8F",
				"\x1\x90",
				"\x1\x91",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"",
				"\x1\x94",
				"\x1\x95",
				"\x1\x96",
				"",
				"",
				"",
				"\x1\x97",
				"\x1\x98",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				"\x1\x9A",
				"",
				"\xA\x17\x7\xFFFF\x1A\x17\x4\xFFFF\x1\x17\x1\xFFFF\x1A\x17",
				""
			};

            private static readonly short[] DFA28_eot = DFA.UnpackEncodedString(DFA28_eotS);
            private static readonly short[] DFA28_eof = DFA.UnpackEncodedString(DFA28_eofS);
            private static readonly char[] DFA28_min = DFA.UnpackEncodedStringToUnsignedChars(DFA28_minS);
            private static readonly char[] DFA28_max = DFA.UnpackEncodedStringToUnsignedChars(DFA28_maxS);
            private static readonly short[] DFA28_accept = DFA.UnpackEncodedString(DFA28_acceptS);
            private static readonly short[] DFA28_special = DFA.UnpackEncodedString(DFA28_specialS);
            private static readonly short[][] DFA28_transition;

            static DFA28()
            {
                int numStates = DFA28_transitionS.Length;
                DFA28_transition = new short[numStates][];
                for (int i = 0; i < numStates; i++)
                {
                    DFA28_transition[i] = DFA.UnpackEncodedString(DFA28_transitionS[i]);
                }
            }

            public DFA28(BaseRecognizer recognizer)
            {
                this.recognizer = recognizer;
                this.decisionNumber = 28;
                this.eot = DFA28_eot;
                this.eof = DFA28_eof;
                this.min = DFA28_min;
                this.max = DFA28_max;
                this.accept = DFA28_accept;
                this.special = DFA28_special;
                this.transition = DFA28_transition;
            }

            public override string Description { get { return "1:1: Tokens : ( T__51 | T__52 | T__53 | T__54 | IN | NOTIN | EQUALS | NOTEQUALS | GREATERTHAN | GREATERTHANOREQUAL | LESSTHAN | LESSTHANOREQUAL | NOT | OR | AND | ASC | DESC | ALLPAGES | NONE | SKIP | TOP | FILTER | ORDERBY | SELECT | INLINECOUNT | COUNT | STARTSWITH | ENDSWITH | SUBSTRINGOF | MIN | MAX | SUM | AVERAGE | INT | LONG | DOUBLE | SINGLE | BOOL | NULL | DATETIME | GUID | BYTE | SPACE | NEWLINE | IDENTIFIER | STRING );"; } }

            public override void Error(NoViableAltException nvae)
            {
                DebugRecognitionException(nvae);
            }
        }


        #endregion

    }

} // namespace Nd.Platform.Querys