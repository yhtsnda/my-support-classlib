grammar AvalonQuery;

options {
    language=CSharp3;
    TokenLabelType=CommonToken;
    output=AST;
    ASTLabelType=CommonTree;
}


@lexer::namespace{Nd.Platform.Querys}
@parser::namespace{Nd.Platform.Querys}

/*
 * Parser Rules
 */

public
prog
	:	(param ('&'! param)*)*;

param	:	(orderby | top | skip | filter | select | inlinecount | count);

skip	
	:	SKIP^ INT+;

top	
	:	TOP^ INT+;

filter	
	:	FILTER^ filterexpression[false];
	
select
	:	SELECT^ propertyname (SPACE? ',' SPACE? propertyname)*;
			
	
inlinecount
	:	INLINECOUNT^ ALLPAGES
	|	INLINECOUNT NONE ->;
count
	:	COUNT^ BOOL;
filterexpression[bool subquery]
	:	orexpression[subquery] (SPACE! OR^ SPACE! orexpression[subquery])*;
	
orexpression[bool subquery]
	:	andexpression[subquery] (SPACE! AND^ SPACE! andexpression[subquery])*;
	
andexpression[bool subquery]
	:	NOT^ SPACE ('(' filterexpression[subquery] ')' | booleanexpression[subquery])
	|	('(' filterexpression[subquery] ')' | booleanexpression[subquery]);
		
booleanexpression[bool subquery]
	:	atom1=atom[subquery] (
			SPACE (op=EQUALS | op=NOTEQUALS | op=GREATERTHAN | op=GREATERTHANOREQUAL | op=LESSTHAN | op=LESSTHANOREQUAL) SPACE atom2=atom[subquery] 	
			-> ^($op $atom1 $atom2)
		|	-> ^(EQUALS["eq"] $atom1 BOOL["true"])
		);

atom[bool subquery]
	:	inexpression
	|	functioncall
	|	constant
	|	propertyname;
	
inexpression
	:	propertyname SPACE (IN|NOTIN)^ SPACE?'(' SPACE? constant? (SPACE? ',' SPACE? constant)* SPACE? ')';
		
functioncall
	:	function^ SPACE? '('SPACE? atom[false] (SPACE? ',' SPACE? constant)* SPACE? ')';
	
function
	:	STARTSWITH | ENDSWITH | SUBSTRINGOF;
		
orderby
	:	ORDERBY^ orderbylist;
	
orderbylist
	:	orderpropertyname (SPACE? ','!  SPACE? orderpropertyname)*;

orderpropertyname
	:	propertyname (
			-> ^(ASC["asc"] propertyname)
			| (SPACE (op=ASC | op=DESC)) -> ^($op propertyname)
		);
	
constant:	(INT^ | BOOL^ | STRING^ | DATETIME^ | LONG^ | SINGLE^ | DOUBLE^ | GUID^ | BYTE^ | NULL^);

propertyname 
	:	IDENTIFIER;

filteroperator
	:	EQUALS | NOTEQUALS | GREATERTHAN | GREATERTHANOREQUAL | LESSTHAN | LESSTHANOREQUAL;

IN	:	'in';

NOTIN	:	'notin';

EQUALS	
	:	'eq';	
	
NOTEQUALS	
	:	'ne';	
	
GREATERTHAN	
	:	'gt';	
	
GREATERTHANOREQUAL
	:	'ge';	
	
LESSTHAN	
	:	'lt';	
	
LESSTHANOREQUAL
	:	'le';	

NOT		
	:	'not';

OR	
	:	'or';

AND	
	: 	'and';

ASC	
	:	'asc';
	
DESC	
	:	'desc';	
	
ALLPAGES
	: 	'allpages';
	
NONE
	:	'none';

SKIP
	:	'$skip=';

TOP
	:	'$top=';

FILTER
	:	'$filter=';


ORDERBY
	:	'$orderby=';
	
SELECT
	:	'$select=';
	
INLINECOUNT
	:	'$inlinecount=';

COUNT
	:	'$count=';

STARTSWITH
	:	'startswith';
	
ENDSWITH
	:	'endswith';
	
SUBSTRINGOF
	:	'substringof';

MIN	:	'min';

MAX	:	'max';

SUM	:	'sum';

AVERAGE	:	'average';
		
INT	:	('-')? '0'..'9'+;
	
LONG	:	('-')? ('0'..'9')+ 'L';
	
DOUBLE	:	('-')? ('0'..'9')+ '.' ('0'..'9')+;
	
SINGLE	:	('-')? ('0'..'9')+ '.' ('0'..'9')+ 'f';
	
BOOL	:	('true' | 'false');

NULL	:	'null';

DATETIME
	:	'datetime\'' '0'..'9'+ '-' '0'..'9'+ '-' + '0'..'9'+ 'T' '0'..'9'+ ':' '0'..'9'+ (':' '0'..'9'+ ('.' '0'..'9'+)*)* '\'';
	
GUID	:	'guid\'' HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR '-' HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR HEX_PAIR '\'';

BYTE	:	'0x' HEX_PAIR;

SPACE	:	(' '|'\t')+;

NEWLINE :	('\r'|'\n')+;
	
fragment
HEX_PAIR
	: HEX_DIGIT HEX_DIGIT;
	
IDENTIFIER
	:	('a'..'z'|'A'..'Z'|'0'..'9'|'_')+;
	
STRING 	: 	'\'' (ESC_SEQ| ~('\\'|'\''))* '\'';

fragment
HEX_DIGIT : ('0'..'9'|'a'..'f'|'A'..'F') ;

fragment
ESC_SEQ
	: '\'\''
		| '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
		| UNICODE_ESC
		| OCTAL_ESC
		;

fragment
OCTAL_ESC
		:   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
		|   '\\' ('0'..'7') ('0'..'7')
		|   '\\' ('0'..'7')
		;

fragment
UNICODE_ESC
		:   '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT